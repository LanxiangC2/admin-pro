## 自动引入
自动引入 `auto-import`, 无需手动引入, 避免了重复了代码，见 vite.config.ts
```
AutoImport({
    // 定义需要自动引入的框架
    imports: ['vue', 'vue-router', 'pinia'],
    // 处理 eslint, 记得还要去 eslint.config.js 中配置这个自动生成的 `.eslintrc-auto-import.json`规则
    eslintrc: {
        enabled: true // Default `false` 
    },
    // 组建的按需引入
    resolvers: [ElementPlusResolver(), IconsResolver()],
    dts: fileURLToPath(new URL('./types/auto-imports.d.ts', import.meta.url))
}),
```

## 解决问题的思路

### less 中变量的使用，要引入
```less
// <style lang="less" scoped></style> 中
@import '@/styles/variables.less';

.wrap-root {
    color: @color;
    background-color: @bgColor;
}
```

那么问题来了，如果很多文件都要用到 less 变量，每次都引入，是不是很麻烦？
早期开发vue2的时候，用到了 webpack, 其中处理 less 必须要用到其中的 less-loader
那么思路就是
1. 看 less-loader 文档，看下有没有提供这样的能力。
    例如，通过查阅文档我们发现，它提供了additinalData 属性，可以传入一个对象，这个对象会被合并到全局变量中。
2. 然后看下 vue-cli 的文档呢？发现有解决方案了
   [向预处理器 Loader 传递选项](https://cli.vuejs.org/zh/guide/css.html#%E5%90%91%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader-%E4%BC%A0%E9%80%92%E9%80%89%E9%A1%B9)

```
vue-cli
    webpack
        less-loader
```

3. 同样的道理，我们去看下 vite 文档，看下有没有这样的能力。

```
vite
    esbuild
    rollup
```

4. vite 文档中共享选项，看有没有
[css.preprocessorOptions](https://cn.vite.dev/config/shared-options.html#css-modules)

### types 类型声明管理

## 最佳实践
### ts 类型声明你真的会用么？
```vue

<script setup lang="ts">

const form = ref<Form>()

// formRef.value.validate()
</script>
```

我使用 elment ui 想要编辑器自动提示 validate

这个时候就要检测我们输入的类型（范型）对不对了
正确的写法是

```js
const formRef = ref<InstanceType<typeof ElForm>>()
```

typeof 获取到类的类型，然后通过 InstanceType 获取到实例类型

那每次我都要这么去写吗？

可以做进一步的封装useCompRef.ts
```ts
import { ref } from 'vue';
export function useCompRef<T extends abstract new (...args: any) => any>() {
    return ref<InstanceType<T>>();
}
```

上边的使用就可以写成

```ts
import { useCompRef } from '@/hooks';

const formRef = useCompRef<typeof ElForm>()
```

### 封装了一些组件，如何让他自动引入呢？

先看下 element ui 都是怎么开发的

[unplugin-vue-components](https://github.com/unplugin/unplugin-vue-components)

看他官网发现有关于自动引入相关的说明

[Types for global registered components](https://github.com/unplugin/unplugin-vue-components?tab=readme-ov-file#types-for-global-registered-components)

结果发现实现这个功能很简单

```ts
// 自动注册组件
Components({
    resolvers: [IconsResolver(), ElementPlusResolver()],
    dts: fileURLToPath(new URL('./types/components.d.ts', import.meta.url)),
    dirs: [fileURLToPath(new URL('./src/components/auto', import.meta.url))]
}),
```

### 面包屑功能实现
router 拦截处理，通过一个方法，获取当前路由，找到父级路由，然后拼接成一个数组

实质就是对数组的操作